# 关于Deadlock的研究和探讨 
From：14M2 刘锦明 14353200

##一：Deadlock简介
###1. Deadlock是什么
>死锁就是两个或者多个进程，互相请求对方占有的资源。  

###2. 产生Deadlock的四个必要条件  
>互斥条件：一个资源每次只能被一个进程使用  
>请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放  
>不剥夺条件:进程已获得的资源，在末使用完之前，不能强行剥夺  
>循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系  


##二：Deadlock实验  
###1. 程序
![](https://github.com/liujm23/ES2016_14353200/raw/pngs/deadlock1.png)   
![](https://github.com/liujm23/ES2016_14353200/raw/pngs/deadlock0.png) 
![](https://github.com/liujm23/ES2016_14353200/raw/pngs/deadlock2.png)   
###2. 结果  
![](https://github.com/liujm23/ES2016_14353200/raw/pngs/deadlock3.png)   
###3. 原因分析
从结果中我们可以看到，程序运行到第16次的时候就停了下来，说明此时产生了死锁！  
我们来分析一下代码：关键字 **synchronized**  
· 当它用来修饰一个方法或者一个代码块的时候，能够保证在同一时刻最多只有一个线程执行该段代码。  
· 当一个线程访问object的一个synchronized同步代码块或同步方法时，其他线程对object中所有其它synchronized同步代码块或同步方法的访问将被阻塞。  

这说明，这里已经满足了互斥条件和不剥夺条件。  
我们继续观察代码，发现主程序先运行a.methodA(b)，然后紧接着运行b.methodB(a)  
并且将这个过程不断地循环下去！  
假如当着四个线程中的某两个线程同时发生时，便满足了产生死锁的四个必要条件，同时线程都会被挂起，产生无限等待的状况！  
也就是如上面的结果所示。


##三：实验心得  
这次实验让我们学习了Deadlock的原理和产生原因，并且让我们亲自动手编写能够产生死锁的简单代码，充分深入了解和体验了死锁的产生原因以及结果。
经过这一次实验，我明白到只有理解了死锁产生原因，我们才能学会如何去避免死锁的产生，以及解决实验中所发生的的死锁现象。  
我个人认为，在多线程开发中，容易出现死锁导致程序挂起的现象，这是由于多个线程申请资源而导致资源无法合理分配产生的，要解决死锁，可以分为三个步骤：  
		1. 检测死锁线程  
		2. 打印线程信息  
		3. 修改死锁程序  
熟练掌握着三个步骤，我们就可以解决大部分情况下的死锁现象了。